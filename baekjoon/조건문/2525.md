# 📘 오븐 시계

- **플랫폼**: 백준
- **문제 번호**: 2525
- **링크**: [https://www.acmicpc.net/problem/2525](https://www.acmicpc.net/problem/2525)

---

## 🧩 풀이 흐름

1. 입력값 3개 (`시`, `분`, `추가분`) 숫자로 받음
2. `분 + 추가분` → 60으로 나눠 몫은 `시로 carry`, 나머지는 분
3. `시 + carry` → 24로 나눈 나머지가 최종 시

---

## 🧾 내 코드

<details>
<summary>✅ 시도한 코드 (런타임: 96ms)</summary>

```node
const getM = (a, b) => [(a + b) % 60, Math.floor((a + b) / 60)];
const getH = (a, b) => Number((a + b) % 24);

const fs = require('fs');

const [ref, m] = fs.readFileSync(0, 'utf-8').trim().split('\n');
const [refH, refM] = ref.trim().split(' ').map(Number);

const [answerM, hc] = getM(refM, Number(m));
console.log(getH(refH, hc) + ' ' + Number(answerM));
```
</details>

♻️ 리팩터링 (92ms)
<details> 
<summary>🧪 간결한 코드 + 소폭 성능 개선</summary>
  
```node
const [a, b, c] = require('fs').readFileSync(0).toString().trim().split(/\s+/).map(Number);
const total = b + c;
const h = (a + Math.floor(total / 60)) % 24;
const m = total % 60;
console.log(h + ' ' + m);
```
split(/\s+/)으로 한 줄 분리 → 코드 간소화

함수 없이 인라인 계산 → call stack 부담 ↓

</details>

## ⏱️ 풀이 시간
- 총 소요: 25분
- 문제 분석: ~5분
- 디버깅 / 런타임 원인 찾기: ~15분
- 리팩터링 비교 / 개선: ~5분

### 느렸던 이유
1. split 구조에서 문자열 처리 방식 착오 (refH, refM = ref)
2. m의 형 변환 누락도 있었음 → 덧셈 시 NaN 유발

## 🧩 배운 점
- fs.readFileSync() 결과는 항상 문자열 / Buffer → 직접 형 변환 필수
- 문제 입력이 여러 줄이라도, split(/\s+/)로 간단히 세 수 추출 가능
- 단순 연산은 함수로 빼는 것보다 인라인 계산이 더 빠를 수 있음 (특히 반복 안 되면)
  
## 🔍 개선 포인트 / TODO
- 입력에서 숫자 3개 받을 때는 항상 split(/\s+/).map(Number) 구조로 시작
- 형변환은 .map(Number) vs +v 등 의도적으로 고정해둘 것
- 다음부터는 문제 읽고 바로 "입력 줄 수 / 숫자 개수 / 기준 단위" 먼저 정리
