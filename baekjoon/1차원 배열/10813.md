# 백준 10813번 - 공 바꾸기

## 문제 요약
- N개의 바구니가 있음 (1번부터 N번까지)
- 각 바구니에는 바구니 번호와 같은 공이 들어있음
- M번의 작업을 수행
- 각 작업: i번 바구니와 j번 바구니의 공을 서로 바꿈
- 최종 바구니 상태 출력

## 초기 코드 (비효율적)

```javascript
let input = `5 4
1 2
3 4
1 4
2 2`.split('\n').map(v => v.split(' ').map(Number));

const [[N, M], ...ops] =  input;
const basket = Array.from({ length: N}, (_, i) => i + 1);

for(const [i, j] of ops) {
    const o = basket[i - 1];
    const t = basket[j - 1];

    basket[i - 1] = t;
    basket[j - 1] = o;
}

console.log(basket.join(' '))
```

### 문제점
- **하드코딩된 입력**: 실제 백준 입력과 다름
- **임시 변수 사용**: 교환에 임시 변수 2개 필요
- **가독성 부족**: 변수명이 모호함 (o, t)
- **불필요한 주석**: 실행 과정 주석이 코드에 포함

## 개선된 코드 (효율적)

```javascript
const fs = require('fs');
const input = fs.readFileSync(0, 'utf-8').trim().split('\n').map(v => v.split(' ').map(Number));

const [[N, M], ...operations] = input;
const baskets = Array.from({ length: N }, (_, i) => i + 1);

// 각 작업 수행 (공 바꾸기)
for (const [i, j] of operations) {
    // 구조분해할당으로 간단하게 교환
    [baskets[i - 1], baskets[j - 1]] = [baskets[j - 1], baskets[i - 1]];
}

console.log(baskets.join(' '));
```

### 개선점
- **올바른 입력 처리**: 실제 백준 입력 방식 사용
- **구조분해할당**: 임시 변수 없이 직접 교환
- **가독성 향상**: 명확한 변수명 사용
- **코드 간소화**: 3줄 → 1줄로 교환 로직 단순화

## 성능 분석

### 시간 복잡도
- **O(M)**: M번의 작업을 수행
- **교환 연산**: O(1) 시간에 두 요소 교환

### 공간 복잡도
- **O(N)**: N개 바구니 배열 사용

## 추가 최적화 방안

### 1. 더 간결한 코드
```javascript
const fs = require('fs');
const input = fs.readFileSync(0, 'utf-8').trim().split('\n').map(v => v.split(' ').map(Number));

const [[N, M], ...operations] = input;
const baskets = Array.from({ length: N }, (_, i) => i + 1);

operations.forEach(([i, j]) => {
    [baskets[i - 1], baskets[j - 1]] = [baskets[j - 1], baskets[i - 1]];
});

console.log(baskets.join(' '));
```

### 2. 함수로 분리 (재사용성)
```javascript
const fs = require('fs');
const input = fs.readFileSync(0, 'utf-8').trim().split('\n').map(v => v.split(' ').map(Number));

const [[N, M], ...operations] = input;
const baskets = Array.from({ length: N }, (_, i) => i + 1);

// 교환 함수
const swap = (arr, i, j) => {
    [arr[i], arr[j]] = [arr[j], arr[i]];
};

operations.forEach(([i, j]) => {
    swap(baskets, i - 1, j - 1);
});

console.log(baskets.join(' '));
```

### 3. reduce 사용 (함수형 스타일)
```javascript
const fs = require('fs');
const input = fs.readFileSync(0, 'utf-8').trim().split('\n').map(v => v.split(' ').map(Number));

const [[N, M], ...operations] = input;

const result = operations.reduce((baskets, [i, j]) => {
    [baskets[i - 1], baskets[j - 1]] = [baskets[j - 1], baskets[i - 1]];
    return baskets;
}, Array.from({ length: N }, (_, i) => i + 1));

console.log(result.join(' '));
```

## 교환 방법 비교

### 1. 임시 변수 사용 (전통적)
```javascript
const temp = arr[i];
arr[i] = arr[j];
arr[j] = temp;
```

### 2. 구조분해할당 (현대적)
```javascript
[arr[i], arr[j]] = [arr[j], arr[i]];
```

### 3. XOR 교환 (비트 연산)
```javascript
arr[i] ^= arr[j];
arr[j] ^= arr[i];
arr[i] ^= arr[j];
```

## 성능 비교

| 방법 | 시간 복잡도 | 공간 복잡도 | 가독성 | 메모리 효율성 |
|------|-------------|-------------|--------|---------------|
| 임시 변수 | O(1) | O(1) | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| 구조분해할당 | O(1) | O(1) | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| XOR 교환 | O(1) | O(1) | ⭐⭐ | ⭐⭐⭐⭐⭐ |
| forEach | O(M) | O(N) | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |

## 결론
- **구조분해할당**: 가장 현대적이고 가독성 좋은 교환 방법
- **임시 변수**: 전통적이지만 안정적이고 메모리 효율적
- **XOR 교환**: 메모리 효율적이지만 가독성이 떨어짐
- **forEach**: 함수형 프로그래밍 스타일로 깔끔함

이 문제는 **구조분해할당을 활용한 교환**이 가장 효율적이고 현대적인 해결책입니다! 