# 백준 10810번 - 공 넣기

## 문제 요약
- N개의 바구니가 있음 (1번부터 N번까지)
- M번의 작업을 수행
- 각 작업: i번부터 j번 바구니까지 k번 공을 넣음
- 최종 바구니 상태 출력

## 초기 코드 (비효율적)

```javascript
let input = `5 4
1 2 3
3 4 4
1 4 1
2 2 2`.split('\n').map(v => v.split(' ').map(Number));

const max = input[0][0];
const counts = input.slice(1);

const answer = new Map();

for(let i = 1; i <= max; i ++) {
    answer.set(i, 0);    
}

for(let i = 0; i < counts.length; i ++) {
    const [start, end, c] = counts[i];
    for(let j = start; j <= end; j ++) {
        answer.set(j, c);
    }
}

console.log([...answer.values()].join(' '))
```

### 문제점
- **하드코딩된 입력**: 실제 백준 입력과 다름
- **Map 사용**: 배열 인덱스에 Map은 과도함
- **비효율적인 출력**: `[...answer.values()]`로 스프레드 연산자 사용
- **가독성 부족**: 변수명이 모호함

## 개선된 코드 (효율적)

```javascript
const fs = require('fs');
const input = fs.readFileSync(0, 'utf-8').trim().split('\n').map(v => v.split(' ').map(Number));

const [N, M] = input[0];
const operations = input.slice(1);

// 배열로 초기화 (Map 대신)
const baskets = new Array(N + 1).fill(0);

// 각 작업 수행
for (const [start, end, ball] of operations) {
    for (let i = start; i <= end; i++) {
        baskets[i] = ball;
    }
}

// 결과 출력 (1번부터 N번까지)
console.log(baskets.slice(1).join(' '));
```

### 개선점
- **올바른 입력 처리**: 실제 백준 입력 방식 사용
- **배열 사용**: Map 대신 배열로 메모리 효율성 향상
- **직접 접근**: 배열 인덱스로 O(1) 접근
- **가독성 향상**: 명확한 변수명 사용

## 성능 분석

### 시간 복잡도
- **O(N × M)**: 각 작업마다 범위의 모든 바구니를 업데이트
- **배열 접근**: O(1) 시간에 인덱스 접근

### 공간 복잡도
- **O(N)**: N+1 크기의 배열 사용

## 추가 최적화 방안

### 1. 더 간결한 코드
```javascript
const fs = require('fs');
const input = fs.readFileSync(0, 'utf-8').trim().split('\n').map(v => v.split(' ').map(Number));

const [N, M] = input[0];
const baskets = new Array(N + 1).fill(0);

input.slice(1).forEach(([start, end, ball]) => {
    for (let i = start; i <= end; i++) {
        baskets[i] = ball;
    }
});

console.log(baskets.slice(1).join(' '));
```

### 2. 구조분해할당 활용
```javascript
const fs = require('fs');
const input = fs.readFileSync(0, 'utf-8').trim().split('\n').map(v => v.split(' ').map(Number));

const [[N, M], ...operations] = input;
const baskets = new Array(N + 1).fill(0);

operations.forEach(([start, end, ball]) => {
    for (let i = start; i <= end; i++) {
        baskets[i] = ball;
    }
});

console.log(baskets.slice(1).join(' '));
```

### 3. fill 메서드 활용 (가장 간결)
```javascript
const fs = require('fs');
const input = fs.readFileSync(0, 'utf-8').trim().split('\n').map(v => v.split(' ').map(Number));

const [[N, M], ...operations] = input;
const baskets = new Array(N + 1).fill(0);

operations.forEach(([start, end, ball]) => {
    baskets.fill(ball, start, end + 1);
});

console.log(baskets.slice(1).join(' '));
```

## 성능 비교

| 방법 | 시간 복잡도 | 공간 복잡도 | 가독성 | 메모리 효율성 |
|------|-------------|-------------|--------|---------------|
| Map 사용 | O(N × M) | O(N) | ⭐⭐ | ⭐⭐ |
| 배열 + for 루프 | O(N × M) | O(N) | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| 배열 + forEach | O(N × M) | O(N) | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| 배열 + fill | O(N × M) | O(N) | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |

## 결론
- **Map → 배열**: 인덱스 기반 접근에 배열이 더 적합
- **fill 메서드**: 범위 업데이트에 가장 효율적
- **구조분해할당**: 코드를 더 간결하게 만듦
- **forEach**: 함수형 프로그래밍 스타일로 가독성 향상

이 문제는 **배열의 fill 메서드**를 활용하면 가장 효율적이고 간결한 코드를 작성할 수 있습니다!

## 10807번 vs 10810번 자료구조 선택 비교

### 왜 10807번은 Map이 좋고, 10810번은 배열이 좋을까?

#### 10807번 (개수 세기)
```javascript
// 입력: [1, 4, 1, 2, 4, 2, 4, 2, 3, 4, 4]
// 찾을 값: 2
// 문제: 배열에서 특정 값이 몇 개인지 세기
```

**Map이 좋은 이유:**
- **연속되지 않은 값들**: 1, 4, 1, 2, 4, 2... (순서가 랜덤)
- **빈도 계산**: 각 숫자가 몇 번 나오는지 세기
- **O(1) 검색**: `frequency.get(target)`로 빠른 접근

#### 10810번 (공 넣기)
```javascript
// 입력: 5개 바구니 (1번~5번)
// 작업: 1번~3번 바구니에 공 2번 넣기
// 문제: 연속된 인덱스에 같은 값 넣기
```

**배열이 좋은 이유:**
- **연속된 인덱스**: 1번, 2번, 3번... (순서대로)
- **범위 업데이트**: start~end까지 같은 값으로 채우기
- **직접 접근**: `baskets[i] = ball`로 O(1) 접근

### 핵심 차이점 정리

| 구분 | 10807번 | 10810번 |
|------|---------|---------|
| **데이터 특성** | 랜덤한 값들 | 연속된 인덱스 |
| **접근 패턴** | 값 검색 | 인덱스 기반 접근 |
| **최적 자료구조** | Map (빈도 계산) | 배열 (인덱스 접근) |
| **사용 목적** | 개수 세기 | 범위 업데이트 |

### 예시로 비교

#### 10807번 - Map이 적합한 경우
```javascript
const numbers = [1, 4, 1, 2, 4, 2, 4, 2, 3, 4, 4];
const frequency = new Map();

// 각 숫자의 빈도 계산
numbers.forEach(num => {
    frequency.set(num, (frequency.get(num) || 0) + 1);
});

console.log(frequency.get(2)); // 2번이 몇 개인지
```

#### 10810번 - 배열이 적합한 경우
```javascript
const baskets = new Array(6).fill(0); // 0번~5번

// 1번~3번 바구니에 공 2번 넣기
for (let i = 1; i <= 3; i++) {
    baskets[i] = 2; // 직접 인덱스 접근
}
```

**핵심**: **데이터의 특성과 사용 목적**에 따라 적절한 자료구조를 선택하는 것이 중요합니다! 