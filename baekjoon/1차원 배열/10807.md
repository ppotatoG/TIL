# 백준 10807번 - 개수 세기

## 문제 요약
- 정수 N개가 주어짐
- 정수 v가 몇 개인지 세기
- 입력: N, N개의 정수들, 찾을 정수 v
- 출력: v의 개수

## 초기 코드 (비효율적)

```javascript
let input = `11
1 4 1 2 4 2 4 2 3 4 4
2`.split('\n');

const [_, array, v] = input;
console.log(array.split(' ').filter(a => Number(a) === Number(v)).length)
```

### 문제점
- **하드코딩된 입력**: 실제 백준 입력과 다름
- **중복 변환**: `Number()` 변환이 여러 번 발생
- **가독성 부족**: 한 줄에 모든 로직이 집중

## 개선된 코드 (효율적)

```javascript
const fs = require('fs');
const input = fs.readFileSync(0, 'utf-8').trim().split('\n');

const [_, array, v] = input;
const numbers = array.split(' ').map(Number);
const target = Number(v);

console.log(numbers.filter(num => num === target).length);
```

### 개선점
- **올바른 입력 처리**: 실제 백준 입력 방식 사용
- **한 번만 변환**: `map(Number)`로 한 번에 숫자 변환
- **가독성 향상**: 변수명으로 의도 명확화

## 성능 분석

### 시간 복잡도
- **O(n)**: 배열을 한 번 순회하며 개수 세기
- **filter() + length**: 내장 메서드 사용으로 최적화됨

### 공간 복잡도
- **O(n)**: 입력 배열 크기만큼 메모리 사용

## 추가 최적화 방안

### 1. reduce 사용 (메모리 효율적)
```javascript
const fs = require('fs');
const input = fs.readFileSync(0, 'utf-8').trim().split('\n');

const [_, array, v] = input;
const numbers = array.split(' ').map(Number);
const target = Number(v);

const count = numbers.reduce((acc, num) => acc + (num === target ? 1 : 0), 0);
console.log(count);
```

### 2. for 루프 사용 (가장 빠름)
```javascript
const fs = require('fs');
const input = fs.readFileSync(0, 'utf-8').trim().split('\n');

const [_, array, v] = input;
const numbers = array.split(' ').map(Number);
const target = Number(v);

let count = 0;
for (let num of numbers) {
    if (num === target) count++;
}
console.log(count);
```

### 3. Map을 사용한 빈도 계산 (여러 번 세야 할 때)
```javascript
const fs = require('fs');
const input = fs.readFileSync(0, 'utf-8').trim().split('\n');

const [_, array, v] = input;
const numbers = array.split(' ').map(Number);
const target = Number(v);

const frequency = new Map();
for (let num of numbers) {
    frequency.set(num, (frequency.get(num) || 0) + 1);
}

console.log(frequency.get(target) || 0);
```

## 성능 비교

| 방법 | 시간 복잡도 | 공간 복잡도 | 가독성 | 메모리 효율성 |
|------|-------------|-------------|--------|---------------|
| filter + length | O(n) | O(n) | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |
| reduce | O(n) | O(1) | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| for 루프 | O(n) | O(1) | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| Map 빈도 | O(n) | O(k) | ⭐⭐⭐⭐ | ⭐⭐ |

## 결론
- **filter + length**: 가장 직관적이고 가독성 좋음
- **for 루프**: 가장 빠르고 메모리 효율적
- **reduce**: 균형잡힌 선택
- **Map**: 여러 숫자를 세야 할 때 유용

이 문제는 **O(n)** 시간 복잡도가 최적이므로, 가독성과 선호도에 따라 선택하면 됩니다! 