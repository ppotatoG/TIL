# 백준 5622번 - 다이얼

## 문제 요약
전화번호 다이얼에서 각 알파벳을 입력할 때 걸리는 시간을 계산하는 문제

## 다이얼 매핑
- 2: ABC (3초)
- 3: DEF (4초) 
- 4: GHI (5초)
- 5: JKL (6초)
- 6: MNO (7초)
- 7: PQRS (8초) ← **4개 문자**
- 8: TUV (9초)
- 9: WXYZ (10초)

## 학습 포인트

### 1. 문자열 처리와 매핑 전략
- **문자열 순회**: `for...of`, `for...in`, `split()`, `Array.from()` 등 다양한 순회 방법
- **매핑 전략**: 객체, 배열, Map 등 자료구조 선택의 중요성

### 2. 자료구조 선택의 의미
- **객체(Object)**: 키-값 쌍으로 직관적이지만 순서 보장 안됨
- **배열(Array)**: 인덱스 기반 접근, 순서 보장
- **Map**: ES6의 새로운 자료구조, 키 타입 자유로움

### 3. 4개 문자가 있는 경우 처리 방법
- **7번(PQRS)**: 8초
- **9번(WXYZ)**: 10초
- 이는 단순한 선형 관계가 아님을 보여줌

## 해결 방법별 분석

### 방법 1: 객체를 이용한 매핑
```javascript
const dial = {
  'A': 3, 'B': 3, 'C': 3,
  'D': 4, 'E': 4, 'F': 4,
  'G': 5, 'H': 5, 'I': 5,
  'J': 6, 'K': 6, 'L': 6,
  'M': 7, 'N': 7, 'O': 7,
  'P': 8, 'Q': 8, 'R': 8, 'S': 8,  // 4개 문자
  'T': 9, 'U': 9, 'V': 9,
  'W': 10, 'X': 10, 'Y': 10, 'Z': 10  // 4개 문자
};
```
**학습 포인트**: 객체의 키-값 쌍을 이용한 직관적인 매핑

### 방법 2: 배열을 이용한 그룹화
```javascript
const dialGroups = [
  [], // 0, 1번은 사용하지 않음
  [], // 1번도 사용하지 않음
  ['A', 'B', 'C'],     // 2번: 3초
  ['D', 'E', 'F'],     // 3번: 4초
  ['G', 'H', 'I'],     // 4번: 5초
  ['J', 'K', 'L'],     // 5번: 6초
  ['M', 'N', 'O'],     // 6번: 7초
  ['P', 'Q', 'R', 'S'], // 7번: 8초 (4개 문자!)
  ['T', 'U', 'V'],     // 8번: 9초
  ['W', 'X', 'Y', 'Z']  // 9번: 10초 (4개 문자!)
];
```
**학습 포인트**: 배열의 인덱스를 활용한 그룹화, 4개 문자가 있는 경우 자연스럽게 처리

### 방법 3: 수학적 규칙 활용
```javascript
// 각 문자에 대해 다이얼 번호를 구하고 +1을 해서 시간 계산
function getTime(char) {
  if (char <= 'C') return 3;      // 2번
  if (char <= 'F') return 4;      // 3번
  if (char <= 'I') return 5;      // 4번
  if (char <= 'L') return 6;      // 5번
  if (char <= 'O') return 7;      // 6번
  if (char <= 'S') return 8;      // 7번 (4개 문자)
  if (char <= 'V') return 9;      // 8번
  return 10;                       // 9번 (4개 문자)
}
```
**학습 포인트**: ASCII 값 비교를 이용한 수학적 접근, 조건문의 순서가 중요

## 순회 방법별 비교

### 1. for...of (권장)
```javascript
let total = 0;
for (const char of input) {
  total += dial[char];
}
```
**특징**: 문자열의 각 문자를 순차적으로 순회, 가장 직관적

### 2. split() + forEach
```javascript
input.split('').forEach(char => {
  total += dial[char];
});
```
**특징**: 함수형 프로그래밍 스타일, 배열 메서드 활용

### 3. Array.from() + reduce
```javascript
const total = Array.from(input).reduce((sum, char) => sum + dial[char], 0);
```
**특징**: 함수형 프로그래밍, 체이닝 가능, 가장 간결

### 4. 전통적인 for 루프
```javascript
for (let i = 0; i < input.length; i++) {
  total += dial[input[i]];
}
```
**특징**: 인덱스 접근 가능, 가장 빠른 성능

## 성능과 가독성 고려사항

### 성능 순서 (빠른 순)
1. 전통적인 for 루프
2. for...of
3. forEach
4. reduce

### 가독성 순서 (읽기 쉬운 순)
1. for...of
2. forEach
3. reduce
4. 전통적인 for 루프

## 실제 학습 가치

1. **문자열 처리**: 다양한 순회 방법과 각각의 장단점
2. **자료구조 선택**: 문제에 맞는 최적의 자료구조 선택
3. **예외 처리**: 4개 문자가 있는 경우의 자연스러운 처리
4. **코드 스타일**: 함수형 vs 명령형 프로그래밍
5. **성능 고려**: 상황에 맞는 최적화 방법

## 결론
단순한 문제처럼 보이지만, 다양한 접근 방법과 각각의 학습 포인트가 있는 좋은 문제입니다. 특히 4개 문자가 있는 경우를 어떻게 자연스럽게 처리할지, 어떤 자료구조와 순회 방법을 선택할지에 따라 코드의 가독성과 성능이 달라집니다. 