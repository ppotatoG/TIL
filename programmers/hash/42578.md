# [의상](https://school.programmers.co.kr/learn/courses/30/lessons/42578)

## 🧩 문제 설명

- 각 의상은 `[의상이름, 의상종류]`로 주어짐
- 코니는 **같은 종류의 옷을 동시에 2개 이상 입을 수 없음**
- 각 종류별로 **입거나 안 입거나** 선택 가능
- 단, **최소 1개는 반드시 입어야 함**
- 가능한 **조합의 가짓수**를 구하라

## ✅ 문제 핵심 원리

> 의상 종류가 K개일 때,  
> 각 종류별로 `(입는 경우의 수 + 안 입는 경우)`를 곱한 후  
> 마지막에 **“모두 안 입는 경우(1가지)”를 빼면 정답**

즉,  
> **정답 = (a + 1) * (b + 1) * ... * (n + 1) - 1**

- `a, b, ..., n` = 각 의상 종류의 개수

## ✅ 내가 작성한 최종 코드

```js
const solution = (clothes) => {
    const map = new Map();
    
    for (let i = 0; i < clothes.length; i++) {
        const [name, type] = clothes[i];
        
        if (!map.has(type)) {
            map.set(type, 1);
        } else {
            const v = map.get(type);
            map.set(type, v + 1);
        }
    }
    
    let answer = 1;
    map.forEach((size) => {
        answer *= (size + 1);
    });
    
    return answer - 1;
}
```

## 🔍 코드 설명

### 1. `Map`을 사용해 의상 종류별 개수 누적
- 키: 의상 종류 (`type`)
- 값: 해당 종류에 속한 의상 수

### 2. 각 종류별로 `(개수 + 1)`을 누적 곱
- 안 입는 경우 포함 (`+1`)
- 최소 1개는 입어야 하므로 마지막에 `-1`

## ⏱ 시간복잡도

- `for`문으로 `clothes` 한 번 순회 → O(n)
- `map.forEach()`로 종류별 한 번 순회 → O(k)
- 전체 시간복잡도: **O(n)**  
  → 의상 수 최대 30개이므로 매우 효율적
  
## ✅ 평가

| 항목 | 평가 |
|------|------|
| 정확성 | ✅ 문제 조건 완벽히 반영 |
| 효율성 | ✅ O(n)으로 최적 |
| 가독성 | ✅ 명확한 구조와 네이밍 |
| 확장성 | ✅ 다른 조합 문제에도 재사용 가능 |

## 🔚 결론

- 이 코드는 문제의 수학적 원리를 정확히 반영함
- 불필요한 반복이나 문자열 처리 없음
- 해시맵을 통해 의상 종류를 정확히 집계하고 조합 계산으로 연결
- **구조적, 성능적으로 모두 최선에 가까운 풀이**
