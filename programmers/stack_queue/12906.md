# [같은 숫자는 싫어](https://school.programmers.co.kr/learn/courses/30/lessons/12906)

## 🧩 문제 설명

- 숫자 배열 `arr`가 주어질 때,
- **연속으로 같은 숫자가 반복되면 하나만 남기고 제거**
- 숫자의 **순서는 유지**
- 최종적으로 남은 배열을 반환

### 예시

```js
arr = [1, 1, 3, 3, 0, 1, 1]
→ [1, 3, 0, 1]

arr = [4, 4, 4, 3, 3]
→ [4, 3]
```

## ✅ 최종 코드

```js
function solution(arr) {
  return arr.filter((val, idx) => val !== arr[idx - 1]);
}
```

## 🔍 풀이 원리

- `filter`를 이용해 **앞의 값과 다를 때만** 포함시킴
- `arr[idx - 1]`와 비교 → 연속 중복의 **첫 번째만 남음**
- index 0일 때는 `arr[-1]` → undefined → 항상 true → 첫 값은 무조건 포함됨

## ✂️ 잘못된 접근 (비교용 참고)

```js
function solution(arr) {
  return arr.filter((val, idx, array) => val != array[idx + 1]);
}
```

### ❌ 문제점
- 다음 값과 비교하면 **중복 중 마지막 값만 남게 됨**
- 문제 조건은 **앞에 나온 숫자를 남기는 것**이므로 잘못된 방향

## ✅ 추가 단축형

```js
const solution = arr => arr.filter((v, i) => v !== arr[i - 1]);
```

## ⏱ 시간복잡도

- `filter()` → O(n)
- 비교만 수행하므로 성능 부담 없음 (최대 1,000,000까지 처리 가능)

## ✅ 정리

| 항목 | 설명 |
|------|------|
| 요구사항 | 연속 중복 제거, 순서 유지 |
| 핵심 로직 | `이전 값과 비교해서 다르면 포함` |
| 최적화 | `filter` 한 줄로 가능 |
| 시간복잡도 | O(n) |

## 📌 최종 요약

> 이 문제는 "이전 값과 비교"만 잘하면  
> **한 줄 filter로도 깔끔하게 해결 가능**한 문제다.
